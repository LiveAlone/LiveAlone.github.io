---
title: 垃圾回收算法实践 (2)
date: 2020-09-12 01:15:30
tags:
  - GC
  - 垃圾回收
categories:
  - 技术
  - 垃圾回收
  - 算法与实践
---

不同GC 垃圾回收算法, 通过判定对象的存活方式。

#### 标记清除算法

1. 标记阶段: 通过 $Root 根位置， 遍历所有的对象，标记存活的对象。遍历方式 深度遍历， 广度遍历方式。
2. 遍历内存管理对象列表， 没有标记对象，回收内存。 标记对象 恢复未标记状态。

对象分配
通过遍历内存管理链表，找到合适分分块，分配对象。
寻找合适的分块, 不同策略:

- best fit 返回 =需要Size 的最小分块
- First fit 最先找到满足条件的分块
- Worst Fit 找到最大的区块

合并分块
多个对象回收以后，产生多个分块，对于连续分块，进行合并，满足分配较大的对象。

评价
优点: 算法简单。 兼容保守式GC
缺点: 内存碎片化，没有压缩过程。 内存分配速度较慢，需要遍历内存列表，寻找fit 内存。与写时复制Linux 技术不兼容，对于对象没有改变，也会有 Mark 存活标记。

##### 多个空闲链表

上面对内存管理单个链表，每次分配，需要遍历内存，比较慢。 通过管理多个空闲链表， 提高内存分配速度，不同链表， 管理不同内存大小。

##### BIPOP

内存配置分配成大小相同对的快，分配快速寻找分配。
![Bipop](/images/20200920/Bipop.png)

##### 位图标记算法

![bitmark](/images/20200920/bitmark.png)

通过位图标记方式，减少内存对象的修改，保证对象标记， 与 Linux 的写时复制保持一致。防止只读对象，内存复制，时间过长。

##### 延迟清除

上面沟通，垃圾回收时候，清理所有对象，消耗时间较长。 延迟清除，会首先占用所有的内存空间， 等到无法分配以后， 进行垃圾回收操作。

#### 引用计数法

每个对象的头部，新增一个计数器方式，统计对象的引用次数，判断对象的存活情况。
对象引用修改的时候， 需要进行 update_ptr操作， 1. desc 减少就引用对象数量 2. inc 新引用对象数量增加。
desc 引用次数时候， 判断引用次数为0， 这个时候对象标志为垃圾对象，不会在使用。 注意 先inc 后desc, 非原子操作， noLock 防止desc产生对象回收，严重的bug。ref_count = 0 的时候，加入空闲链表中，回收时候，一次性标记回收对象内容。

1. 优点, 1. 可以即刻回收，当ref_count=0 的时候。 2. 最大暂停时间短  3. 没有必要沿着指针查找，即刻标记方式
2. 缺点, 1. 计数器变化更新严重  2. 计数器需要占用内存较大, 每个对象一个  3. 引用修改地方，更新复杂，root 变化，所有树形结构对象都需要变化  4. 循环引用没法回收。

下面对于缺陷一些优化方式

##### 延迟引用计数法

针对**计数器频繁变更**缺陷问题，desc_ref_count 减少引用次数时候，当refCount=0 时候，递归子对象，减少引用次数。提出了延迟引用计数法, desc_ref_count 的时候，不递归子对象。 垃圾回收的时候，遍历所有引用对象0，集体回收对象。

优点，减少耗时。 缺点 垃圾回收时长边长， 吞吐量减低。

##### Sticky 引用计数法

引用计数，头对象，平均占用内存会增加 1.5倍， 为了解决这个问题。 大部分对象ref_count=1 后面就是0，对于引用次数溢出以后， 可以通过标记清除算法方式，后援清理。

1. 一开始所有的对象引用次数设置0
2. 不标记对象，只是对计数器增加
3. 对计数器进行增量操作， 算法对活动对象不止一次操作。

类似通过 计数器方式，进行伪装标记方式， 清除使用对象。 相应的变种 1 位计数法，Sticky 不保证移除，1 位缩减到极致。

##### 部分标记清除算法

引用计数法，会产生循环引用问题。 标记清除就不会，通过标记清除算法，防止循环引用。

4色引用垃圾标记， 黑：一定是活动对象， 白: 一定是垃圾， 灰：搜索完毕对象， 阴影： 可能循环垃圾对象。

通过 hatch_queue 记录 ref_count = 0 的引用对象， 这部分可能产生循环垃圾。 通用引用路径 笔记搜索半径， 保证对象正确回收。

#### GC 复制算法

jvm 年轻代，复制压缩算法。 

1. 优点 1. 较高的吞吐量。 2. 内存new_obj 高速分配。 3. 不会产生碎片化， 深度遍历， 最近附近访问速度。
2. 缺点 1. 堆使用效率低下 2. 不兼容保守GC, 因为移动对象位置 3. 递归回收方式，栈消耗， STW

##### Cheney GC 复制算法

对象复制算法中，从深度优先搜索方式， 换成广度优先搜索方式。 通过队列方式，队列可以存储在 newSpace, 减少了迭代深度遍历带来的开销。但是这样就失去了关联对象快速访问的优势。

##### 近似深度搜索

上面的Cheney GC减少了递归调用栈的内存消耗， 为了保证关联对象引用一直性， 页面当做一个对象，进行近似深度搜索。

![page](/images/20200920/page.png)

##### 多空间复制算法

多空间复制算法，把空间分成 N 份， 每两块进行复制算法。

#### 标记压缩算法

类似标记清除算法，分为标记阶段， 压缩阶段。压缩阶段分成:  1. 设定Forward 指针。  2.  更新指向指针  3. 移动对象。

优点 堆的利用率相对较高。 缺点，压缩时间和内存大小正, 需要遍历三次内存空间， 消耗时间较大。

##### Two Finger 算法

把所有的对象整理成相同大小的分块， 压缩步骤： 1. 移动对象 2. 更新指针。
把上面的 1. 2 步骤压缩成一步执行。 由于分块，对象大小相同，保证对象移动标识可用。
缺点: 对象移动打破， 相邻对象的位置相近。

#### 保守式GC

区别能不能识别， 变量是指针， 还是 value 原始类型变量。 就是面向对象数据类型，彻底处理方式。

准确式GC: 保证准确识别，变量类型， 指针类型。  间接引用: 所有引用通过对象句柄方式，垃圾回收时候，修改句柄地址就好了

#### 分代垃圾回收

JVM 中进行了实践， 年轻代采用GC 复制算法， 老年代时候GC 压缩算法。 通过记录表方式，记录年轻代，对老年代的对象引用。
