---
title: 垃圾回收算法实践 (2)
date: 2020-09-12 01:15:30
tags:
  - GC
  - 垃圾回收
categories:
  - 技术
  - 垃圾回收
  - 算法与实践
---

不同GC 垃圾回收算法, 通过判定对象的存活方式。

#### 标记清除算法

1. 标记阶段: 通过 $Root 根位置， 遍历所有的对象，标记存活的对象。遍历方式 深度遍历， 广度遍历方式。
2. 遍历内存管理对象列表， 没有标记对象，回收内存。 标记对象 恢复未标记状态。

对象分配
通过遍历内存管理链表，找到合适分分块，分配对象。
寻找合适的分块, 不同策略:

- best fit 返回 =需要Size 的最小分块
- First fit 最先找到满足条件的分块
- Worst Fit 找到最大的区块

合并分块
多个对象回收以后，产生多个分块，对于连续分块，进行合并，满足分配较大的对象。

评价
优点: 算法简单。 兼容保守式GC
缺点: 内存碎片化，没有压缩过程。 内存分配速度较慢，需要遍历内存列表，寻找fit 内存。与写时复制Linux 技术不兼容，对于对象没有改变，也会有 Mark 存活标记。

##### 多个空闲链表

上面对内存管理单个链表，每次分配，需要遍历内存，比较慢。 通过管理多个空闲链表， 提高内存分配速度，不同链表， 管理不同内存大小。

##### BIPOP

内存配置分配成大小相同对的快，分配快速寻找分配。
![Bipop](/images/20200920/Bipop.png)

##### 位图标记算法

![bitmark](/images/20200920/bitmark.png)

通过位图标记方式，减少内存对象的修改，保证对象标记， 与 Linux 的写时复制保持一致。防止只读对象，内存复制，时间过长。

##### 延迟清除

上面沟通，垃圾回收时候，清理所有对象，消耗时间较长。 但是等到对象分配失败， 等待一定比例是 垃圾回收，较少停顿时间，并行等等优化方式。

#### 引用计数法

每个对象的头部，新增一个计数器方式，统计对象的引用次数，判断对象的存活情况。
对象引用修改的时候， 需要进行 update_ptr操作， 1. desc 减少就引用对象数量 2. inc 新引用对象数量增加。
desc 引用次数时候， 判断引用次数为0， 这个时候对象标志为垃圾对象，不会在使用。 注意 先inc 后desc, 非原子操作， noLock 防止desc产生对象回收，严重的bug。ref_count = 0 的时候，加入空闲链表中，回收时候，一次性标记回收对象内容。

1. 优点, 1. 可以即刻回收，当ref_count=0 的时候。 2. 最大暂停时间短  3. 没有必要沿着指针查找，即刻标记方式
2. 缺点, 1. 计数器变化更新严重  2. 计数器需要占用内存较大, 每个对象一个  3. 引用修改地方，更新复杂，root 变化，所有树形结构对象都需要变化  4. 循环引用没法回收。

下面对于缺陷一些优化方式

##### 延迟引用计数法

针对**计数器频繁变更**缺陷问题，这个问题，解决Root 变化，引用对象集体变化情况。提出了延迟引用计数法, 通过ZTC 记录引用次数为0 的对象表，对象引用次数 0 时候，记录数据表中。
垃圾回收，根对象遍历 object，引用对象0，集体回收对象。 垃圾不能马上回收，频繁回收，降低了吞吐量。

##### Sticky 引用计数法

引用计数，头对象，平均占用内存会增加 1.5倍， 为了解决这个问题。 大部分对象ref_count=1 后面就是0，对于引用次数溢出以后， 可以通过标记清除算法方式，后援清理。

1. 一开始所有的对象引用次数设置0
2. 不标记对象，只是对计数器增加
3. 对计数器进行增量操作， 算法对活动对象不止一次操作。

类似通过 计数器方式，进行伪装标记方式， 清除使用对象。 相应的变种 1 位计数法，Sticky 不保证移除，1 位缩减到极致。

##### 部分标记清除算法

引用计数法，会产生循环引用问题。 标记清除就不会，通过标记清除算法，防止循环引用。

4色引用垃圾标记， 黑：一定是活动对象， 白: 一定是垃圾， 灰：搜索完毕对象， 阴影： 可能循环垃圾对象。

通过 hatch_queue 记录 ref_count = 0 的引用对象， 这部分可能产生循环垃圾。 通用引用路径 笔记搜索半径， 保证对象正确回收。

#### GC 复制算法

jvm 年轻代，复制压缩算法。 

1. 优点 1. 较高的吞吐量。 2. 内存new_obj 高速分配。 3. 不会产生碎片化， 深度遍历， 最近附近访问速度。
2. 缺点 1. 堆使用效率低下 2. 不兼容保守GC, 因为移动对象位置 3. 递归回收方式，栈消耗， STW

##### Cheney GC 复制算法

TODO 4.4 163
